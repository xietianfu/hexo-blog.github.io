<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ES6标准入门--笔记 | 黑脸花猫</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ES6标准入门--笔记</h1><a id="logo" href="/.">黑脸花猫</a><p class="description">在这世界上的一切人之中，我最希望予以提升的一个，就是我自己。这话很卑鄙，很自私，也很诚实。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/demo/"><i class="fa fa-code"> Test</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">ES6标准入门--笔记</h1><div class="post-content"><h3 id="第二章-let和const命令"><a href="#第二章-let和const命令" class="headerlink" title="第二章 let和const命令"></a>第二章 let和const命令</h3><h4 id="2-1-let命令"><a href="#2-1-let命令" class="headerlink" title="2.1 let命令"></a>2.1 let命令</h4><p><strong>基本用法：</strong>ES6新增命令，用于变量声明，但是声明的变量只在<code>let</code>命令所在的代码块内有效。</p>
<p><strong>特性：</strong></p>
<ul>
<li>不存在变量提升：变量一定要在声明后使用，否者报错。</li>
<li>暂时性死区：只要块级作用域存在<code>let</code>命令，它所在的变量就“绑定”这个区域，不在受到外部的影响。</li>
<li>不允许重复声明。</li>
</ul>
<h4 id="2-2-块级作用域"><a href="#2-2-块级作用域" class="headerlink" title="2.2 块级作用域"></a>2.2 块级作用域</h4><p><strong>为什么需要块级作用域：</strong>ES5只有全局作用域和函数作用域，没有块级作用域。<br><strong>没有块级作用域带来的坏处：</strong></p>
<ol>
<li>内层变量可能会覆盖外层变量。</li>
<li>用来计数的循环变量会泄露为全局变量。</li>
</ol>
<p><strong>块级作用域外部调用内部作用域的方法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> f;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</div><div class="line">  f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-const-命令"><a href="#2-3-const-命令" class="headerlink" title="2.3 const 命令"></a>2.3 const 命令</h4><p><strong>作用：</strong>用来声明常量，一旦声明就不能在改变。</p>
<h4 id="2-4-跨模块常量"><a href="#2-4-跨模块常量" class="headerlink" title="2.4 跨模块常量"></a>2.4 跨模块常量</h4><p><strong>写法：</strong><code>export const A = 1</code>;<br><strong>调用：</strong><code>import { A } from &#39;./constans&#39;</code></p>
<h4 id="2-5-全局对象的属性"><a href="#2-5-全局对象的属性" class="headerlink" title="2.5 全局对象的属性"></a>2.5 全局对象的属性</h4><blockquote>
<p>全局对象时最顶层的对象，在浏览器环境指的是<code>windows</code>对象，在Node.js中指的是<code>global</code>对象。在ES5中，全局对象的属性和全局变量是等价的。</p>
</blockquote>
<p><strong>ES5中全局对象的坏处：</strong>容易不知不觉就创建了全局变量。<br><strong>ES6的解决办法：</strong></p>
<ol>
<li><code>var</code>和<code>function</code>命令声明的全局变量依旧是全局对象的属性。为了保证向下的兼容性。</li>
<li><code>let</code>和<code>const class</code>命令声明的全局变量不属于全局对象的属性。</li>
</ol>
<h3 id="第三章-变量的解构赋值"><a href="#第三章-变量的解构赋值" class="headerlink" title="第三章 变量的解构赋值"></a>第三章 变量的解构赋值</h3><h4 id="3-1-解构的共有特性"><a href="#3-1-解构的共有特性" class="headerlink" title="3.1 解构的共有特性"></a>3.1 解构的共有特性</h4><p><strong>特性：</strong></p>
<ol>
<li>只要等号两边的模式相同，左边的变量就会被赋予对应的值。</li>
<li>如果解构不成功，变量的值就等于<code>undefined</code>。</li>
<li>如果等号的右边不是可遍历的解构，将会报错。</li>
</ol>
<p><strong>默认值：</strong></p>
<ul>
<li><p>ES6内部严格使用<code>===</code>判断是否有值，所以一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>] <span class="comment">//x值为1</span></div><div class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]  <span class="comment">// x值为null</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，只在用到的时候才会求值。</p>
</li>
<li>默认值可以引用解构赋值的其他的变量，但该变量必须已经声明。</li>
</ul>
<h4 id="3-2-数组的解构赋值"><a href="#3-2-数组的解构赋值" class="headerlink" title="3.2 数组的解构赋值"></a>3.2 数组的解构赋值</h4><p><strong>基本用法：</strong>从数组和对象中提取值，对变量进行赋值，这被称为解构。<br>左边的<code>...name</code>表示初始化一个数组。</p>
<h4 id="3-3-对象的解构赋值"><a href="#3-3-对象的解构赋值" class="headerlink" title="3.3 对象的解构赋值"></a>3.3 对象的解构赋值</h4><p><strong>与数组的解构赋值的不同点：</strong>数组的元素是按次序排列，变量的取值由它所在的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;<span class="attr">foo</span>:foo, <span class="attr">bar</span>:bar&#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span>&#125;</div><div class="line"><span class="comment">//如果属性名与变量名一致foo:foo，简写为foo</span></div></pre></td></tr></table></figure>
<p><strong>说明：</strong>对象的解构赋值的内部机制，是先找到同名属性，然后在赋值给对应的变量。真正被赋值的是后者，而不是前者。</p>
<p><strong>注意：</strong></p>
<ol>
<li>采用这种写法时，变量的声明和赋值是一体的。对于<code>let const</code>，变量不能重新声明，一旦重复就会报错。解决办法是在不同的块级作用域中使用。</li>
<li>解构模式是嵌套的对象，而且子对象所在的父属性不存在，将会报错。</li>
<li>将一个已经声明的变量用于解构赋值，必须非常小心。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误的写法</span></div><div class="line"><span class="keyword">var</span> x;</div><div class="line">&#123;x&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="comment">//因为JavaScript引擎会将&#123;x&#125;理解成一个代码块，从而造成语法错误。</span></div><div class="line"><span class="comment">//正确的写法</span></div><div class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-4-字符串的解构赋值"><a href="#3-4-字符串的解构赋值" class="headerlink" title="3.4 字符串的解构赋值"></a>3.4 字符串的解构赋值</h4><p><strong>原因：</strong>字符串被转换诚意类似数组的对象。</p>
<p>其中<code>length</code>属性也可以解构赋值。<code>let {length: len} = &#39;hello&#39; // len值为5</code>。</p>
<h4 id="3-5-数值和布尔值的解构赋值。"><a href="#3-5-数值和布尔值的解构赋值。" class="headerlink" title="3.5 数值和布尔值的解构赋值。"></a>3.5 数值和布尔值的解构赋值。</h4><p><strong>原因：</strong>等号右边是数值或布尔值，则会先转为对象。</p>
<p><strong>注意：</strong>解构赋值的规则是，只要等号右边的值不是对象，就先将其转化为对象。由于<code>undefined和null</code>无法转化为对象，所以对它们进行解构赋值都会报错。</p>
<h4 id="3-6-函数参数的解构赋值"><a href="#3-6-函数参数的解构赋值" class="headerlink" title="3.6 函数参数的解构赋值"></a>3.6 函数参数的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x,y]</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x+y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add([<span class="number">1</span>,<span class="number">2</span>]);;  <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<h4 id="3-7-圆括号问题"><a href="#3-7-圆括号问题" class="headerlink" title="3.7 圆括号问题"></a>3.7 圆括号问题</h4><p>只要有可能导致解构歧义，就不得使用圆括号。</p>
<p><strong>不能使用圆括号的情况：</strong></p>
<ol>
<li>变量声明语句中，模式不能带有圆括号。</li>
<li>函数参数中，模式不能带有圆括号。</li>
<li>不能讲整个模式或嵌套模式中的一层放在圆括号中。</li>
</ol>
<p><strong>可以使用圆括号的情况：</strong>赋值语句的费模式部分可以使用圆括号。</p>
<h4 id="3-8-用途"><a href="#3-8-用途" class="headerlink" title="3.8 用途"></a>3.8 用途</h4><ol>
<li>交换变量的值：<code>[x,y] = [y,x]</code></li>
<li>从函数返回多个值。</li>
<li>提取JSON数据。</li>
<li>函数参数的默认值。</li>
<li>遍历Mao解构：任何部署了<code>Iterator</code>接口的对象，都可以用<code>for...of</code>循环遍历。</li>
<li>输入模块的指定方法。</li>
</ol>
<h3 id="第四章-字符串的扩展"><a href="#第四章-字符串的扩展" class="headerlink" title="第四章 字符串的扩展"></a>第四章 字符串的扩展</h3><h4 id="4-1-模板字符串"><a href="#4-1-模板字符串" class="headerlink" title="4.1 模板字符串"></a>4.1 模板字符串</h4><p>模板字符串是增强版的字符串，用反引号标识。如果使用模板字符串标识多行字符串，所有的空格都会被保留在输出中。在模板字符串中嵌入变量，需要将变量名写在<code>${}</code>中。</p>
<h4 id="4-2-标签模板"><a href="#4-2-标签模板" class="headerlink" title="4.2 标签模板"></a>4.2 标签模板</h4><p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称”标签模板”。标签模板其实不是模板，而是函数调用的一种特殊形式。”标签“指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p><strong>声明与使用：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a, b]=[<span class="number">5</span>, <span class="number">10</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`a: <span class="subst">$&#123;a&#125;</span>  b: <span class="subst">$&#123;b&#125;</span>`</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s,...values</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(s[<span class="number">0</span>]); <span class="comment">// 表示在第一个变量前的值</span></div><div class="line">    <span class="built_in">console</span>.log(s[<span class="number">1</span>]); <span class="comment">//第一个与第二个变量之间的值</span></div><div class="line">    <span class="built_in">console</span>.log(s[<span class="number">2</span>]); <span class="comment">// 最后的值</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(values[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(values[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">tag<span class="string">`Hi  Hello <span class="subst">$&#123;a+b&#125;</span> world <span class="subst">$&#123;a*b&#125;</span> !`</span>;</div><div class="line"><span class="comment">//输出的值</span></div><div class="line"></div><div class="line"><span class="comment">//a: 5  b: 10</span></div><div class="line"><span class="comment">//Hi  Hello </span></div><div class="line"><span class="comment">// world </span></div><div class="line"><span class="comment">// !</span></div></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>模板函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分。</li>
<li>模板函数的其它参数都是模板字符串各个函数被替换后的值。</li>
</ul>
<p><strong>用处：</strong></p>
<ol>
<li>过滤HTML字符串，防止用户恶意输入。</li>
<li>多语言转换。</li>
<li>在JavaScript语言中嵌入其他语言。</li>
</ol>
<h4 id="4-3-String-raw"><a href="#4-3-String-raw" class="headerlink" title="4.3 String.raw()"></a>4.3 String.raw()</h4><p>该方法会将所有变量替换，并对反斜线进行转义，方便下一步作为字符串使用。</p>
<h3 id="第五章-正则的扩展"><a href="#第五章-正则的扩展" class="headerlink" title="第五章 正则的扩展"></a>第五章 正则的扩展</h3><ol>
<li>在ES5中<code>RegExp</code>只能接受字符串作为参数，ES6允许接受正则表达式作为参数。如果有冲突以ES5为准。</li>
<li>所有正则相关的方法都定义在<code>RepExp</code>中。<code>match() replace() search() split()</code></li>
<li>对UTF-16的支持。</li>
<li>新增“粘连”修饰符<code>y</code>。类似<code>g</code>修饰符，但是<code>y</code>修饰符会确保匹配必须从剩余的第一个位置开始。<code>sticky</code>属性检测是否设置了该修饰符。<code>let r=/hellp/y;  r.sticky; //true</code></li>
<li>新增<code>flags</code>返回正则的修饰符。<code>source</code>返回正则表达式的正文。</li>
</ol>
<h3 id="第六章-数值的扩展"><a href="#第六章-数值的扩展" class="headerlink" title="第六章 数值的扩展"></a>第六章 数值的扩展</h3><h4 id="6-1-不同进制的表示法"><a href="#6-1-不同进制的表示法" class="headerlink" title="6.1 不同进制的表示法"></a>6.1 不同进制的表示法</h4><p>从ES5的严格模式开始，八进制就不在允许使用零作为前缀，要使用<code>0o</code>。二进制<code>0b</code>，十六进制<code>0x</code>。</p>
<h4 id="6-2-数值的方法"><a href="#6-2-数值的方法" class="headerlink" title="6.2 数值的方法"></a>6.2 数值的方法</h4><p>ES6将很多的全局方法移植到了<code>Number</code>对象上，行为保持不变。目的是逐步减少全局部方法，使语言逐步模块化。</p>
<ul>
<li><code>Number.isFinite(),Number.isNaN()</code> :用来检测数组是否是<strong>非</strong>无穷和是否为NaN。与传统<code>isFinite(),isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值转为数值，再进行判断，而新方法只对数值有效，对于非数值一律返回<code>false</code>。</li>
<li><code>Number.isInteger()</code>:用来判断一个值是否为整数。注意，在JavaScript内部，整数和浮点数都是同样的储存方法，所以3与3.0是被视为同一个值。</li>
</ul>
<h3 id="第七章-数组的扩展"><a href="#第七章-数组的扩展" class="headerlink" title="第七章 数组的扩展"></a>第七章 数组的扩展</h3><h4 id="7-1-Array-from"><a href="#7-1-Array-from" class="headerlink" title="7.1 Array.from()"></a>7.1 Array.from()</h4><p><strong>作用：</strong><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象和可遍历对象。总之是部署了<code>Iterator</code>接口的数据结构，都能转化为数组。</p>
<p><strong>使用范围：</strong></p>
<ol>
<li>DOM操作返回的Nodelist集合。</li>
<li>函数内部的<code>arguments</code>对象。</li>
<li>扩展运算符（…），其背后调用的是遍历器接口<code>Symbol.iterator</code>，如果一个对象没有部署该接口，就无法转化。</li>
<li>类似数组的对象，本质特征只用一点，必须有<code>length</code>属性。</li>
<li>将字符串转为数组，可以避免字符作为2个字符的bug。</li>
<li>set结构。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Nodelist obj</span></div><div class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</div><div class="line"><span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">p</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(p);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//arguments obj</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> args=<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 拓展运算符</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> args = [...arguments];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 字符串.,set</span></div><div class="line"><span class="built_in">Array</span>.from(<span class="string">'hello'</span>);</div><div class="line"><span class="keyword">let</span> nameset = <span class="keyword">new</span> set ([<span class="string">'a'</span>, <span class="string">'b'</span>]);</div></pre></td></tr></table></figure>
<p><strong>更多扩展：</strong></p>
<ul>
<li>接受第二个参数，作用类似数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</li>
<li>如果<code>map</code>函数里面用到了<code>this</code>关键字，汉可以传入第三个参数，用来绑定<code>this</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> spans = <span class="built_in">document</span>.querySelectorAll(<span class="string">'span.name'</span>);</div><div class="line"></div><div class="line"><span class="comment">// map()</span></div><div class="line"><span class="keyword">let</span> names1 = <span class="built_in">Array</span>.prototype.map.call(spans, s =&gt; s.textContent);</div><div class="line"><span class="comment">//Array.from()</span></div><div class="line"><span class="keyword">let</span> names2 = <span class="built_in">Array</span>.from(spans, s =&gt; s.textContent);</div></pre></td></tr></table></figure>
<h4 id="7-2-Array-of"><a href="#7-2-Array-of" class="headerlink" title="7.2 Array.of()"></a>7.2 Array.of()</h4><p>用于将一组值转化为数组，目的是弥补够着函数<code>Array()</code>的不足。其总是返回参数值组成的数组，如果没有参数，就返回一个空数组。</p>
<p><strong>Array()的不足点：</strong>只有当参数个数不少于2个时，才会返回由参数组成的新数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [ , , , ] length=3 </span></div><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>,<span class="number">11</span>,<span class="number">8</span>) <span class="comment">// [3,11,8]</span></div></pre></td></tr></table></figure></p>
<h4 id="7-3-数组实例"><a href="#7-3-数组实例" class="headerlink" title="7.3 数组实例"></a>7.3 数组实例</h4><ul>
<li><strong>find():</strong>用于找到第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，该回调函数可以接受三个值，依次为当前的值(value)、当前的位置(index)、原数组(arr)，直到第一个返回为true的成员，然后返回该成员。都不符合条件返回<code>undefined</code>。</li>
<li><strong>findIndex():</strong>方法与<code>find()</code>类似，只是返回的是位置，都不符合条件返回-1。</li>
<li><strong>fill():</strong>使用给定的值填充数组，可以接受第二个和第三个参数，用来指定开始位置与结束位置。</li>
<li><strong>entries() keys() values():</strong>三个新方法用来遍历数组，返回一个遍历器对象，可用<code>for ... of</code>循环遍历。他们的区别是：键值对遍历、键名遍历、键值遍历。<br>如果不使用<code>for ... of</code>循环，可用手动调用遍历器对象的<code>next</code>方法进行遍历。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</div><div class="line"><span class="keyword">let</span> entries = letter.entries();</div><div class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></div><div class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></div><div class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-4-数组的空位"><a href="#7-4-数组的空位" class="headerlink" title="7.4 数组的空位"></a>7.4 数组的空位</h4><p>数组的空位指数组的蒙一个位置没有任何值，但空位不是<code>undefined</code>，是没有任何值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>,<span class="literal">undefined</span>] <span class="comment">//true</span></div><div class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p><strong>ES5对空位处理的缺点：</strong>对空位处理很不一致，大多数情况下会忽略空位。</p>
<ul>
<li><code>forEach() filter() every() some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值。</li>
<li><code>join() toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<p><strong>ES6的解决办法：</strong>明确将空位转为<code>undefined</code>。</p>
<p>由于空位的处理规则非常不统一，所有避免出现空位。</p>
<h3 id="第八章-函数的扩展"><a href="#第八章-函数的扩展" class="headerlink" title="第八章  函数的扩展"></a>第八章  函数的扩展</h3><h4 id="8-1-函数参数的默认值"><a href="#8-1-函数参数的默认值" class="headerlink" title="8.1 函数参数的默认值"></a>8.1 函数参数的默认值</h4><p>在ES6之前，不能直接为函数的参数指定默认值，只能变通为<code>y = y || &#39;hello&#39;</code>，但是这种写法的缺点在于，如果y赋值了，但是对象的布尔值为<code>false</code>，则该赋值不起作用。<br>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。但是参数变量是默认声明的，不能使用<code>let const</code>再次声明，否则会报错。</p>
<p><strong>与解构函数默认值结合使用的写法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 写法2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123;x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>)</span>&#123;</div><div class="line"> <span class="keyword">return</span> [x, y]; </div><div class="line">&#125;</div><div class="line"><span class="comment">//x有值，y无值</span></div><div class="line">m1(&#123;<span class="attr">x</span>:<span class="number">3</span>&#125;); <span class="comment">// [3,0]</span></div><div class="line">m2(&#123;<span class="attr">x</span>:<span class="number">3</span>&#125;); <span class="comment">// [3,undefined]</span></div></pre></td></tr></table></figure>
<p>区别：</p>
<ol>
<li>写法一中函数参宿的默认值是空对象，但是设置了对象解构赋值的默认值。</li>
<li>写法二中函数的默认值是一个有具体属性的函数，但是没有设置对象解构的默认值。</li>
</ol>
<p><strong>参数默认值的位置：</strong>当默认值的参数不是尾参数，就无法只省略该参数而不省略其后的参数，除非显示的输入<code>undefined</code>,<code>null</code>没有这个效果。</p>
<p><strong>函数的<code>length</code>属性：</strong>其返回值等于函数的参数个数减去指定了默认值的参数个数。其含义是该函数预期传入的参数个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c=<span class="number">5</span></span>)</span>&#123;&#125;).length <span class="comment">//2</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;&#125;).length <span class="comment">//0</span></div></pre></td></tr></table></figure>
<p><strong>作用域：</strong>如果参数默认值是一个变量，则该变量所处的作用域与其他变量的作用域规则是一样的，即显示当前函数的作用域，然后才是全局作用域。如果调用时函数作用域内部的变量没有生成，结果就会不一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x=<span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y=x</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(y); </div><div class="line">&#125;</div><div class="line">f(<span class="number">2</span>) <span class="comment">//2</span></div><div class="line"></div><div class="line">lex x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y=x</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</div><div class="line">  <span class="built_in">console</span>.log(y);</div><div class="line">&#125;</div><div class="line">f() <span class="comment">//1</span></div><div class="line"><span class="comment">// 如果没有全局变量就会报错</span></div></pre></td></tr></table></figure>
<p><strong>应用：</strong>利用参数默认值，可以指定蒙一个参数不得省略，如果省略可以抛出一个错误。</p>
<h4 id="8-2-rest参数"><a href="#8-2-rest参数" class="headerlink" title="8.2 rest参数"></a>8.2 rest参数</h4><p>用于获取函数的对于参数，其参数搭配的变量是一个数组，所有数组特有的方法都可以用于这个变量，该变量将多余的参数放入其中。<code>...变量名</code></p>
<p><strong>目的：</strong>用来取代<code>arguments</code>对象。</p>
<h4 id="8-3-拓展运算符"><a href="#8-3-拓展运算符" class="headerlink" title="8.3 拓展运算符"></a>8.3 拓展运算符</h4><p><strong>含义：</strong>拓展运算符是三个点<code>...</code>，其好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<p><strong>目的：</strong>代替数组的<code>apply</code>方法。</p>
<p><strong>应用：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 合并数组 */</span></div><div class="line"><span class="comment">//ES5</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>].concat(more);</div><div class="line"><span class="comment">//ES6</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,...more];</div><div class="line"></div><div class="line"><span class="comment">/* 与解构赋值结合 但是其只能放在最后一位，否则会报错 */</span></div><div class="line">a = list[<span class="number">0</span>],rest = list.slice(<span class="number">1</span>);</div><div class="line">[a,...rest] = list;</div><div class="line"></div><div class="line"><span class="comment">/* 如果函数需要返回多个值，其提供了解决这个问题的变通方法。 */</span></div><div class="line"></div><div class="line"><span class="comment">/* 将字符串转化为真正的数组 */</span> </div><div class="line"></div><div class="line"><span class="comment">/* 任何类似数组的对象都可以用其转化为真正的数组 */</span></div><div class="line"></div><div class="line"><span class="comment">/* Map 和 Set 结构，Generator 函数 */</span></div></pre></td></tr></table></figure>
<h4 id="8-4-name属性"><a href="#8-4-name属性" class="headerlink" title="8.4 name属性"></a>8.4 name属性</h4><p>函数的<code>name</code>属性返回该函数的函数名。</p>
<p><strong>ES5:</strong>如果将一个匿名函数赋值给一个变量，返回空字符串。<br><strong>ES6：</strong>…..，返回实际的函数名。<br>将一个具体名字函数赋值给一个变量，都会返回具体名字函数原本的名字。</p>
<h4 id="8-5-箭头函数"><a href="#8-5-箭头函数" class="headerlink" title="8.5 箭头函数"></a>8.5 箭头函数</h4><p><strong>规则：</strong>如果箭头函数的代码块部分多于一条语句，就要使用大括号括起来，并用<code>return</code>语句返回。由于大括号被解释为代码块，所有如果箭头函数直接返回一个对象，必须在独享外面加上括号。</p>
<p><strong>使用注意点：</strong></p>
<ol>
<li>函数体内的<code>this</code>对象就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数。也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>rest</code>参数代替。</li>
<li>不可以使用<code>yield</code>命令，一次箭头函数不能用作<code>Generator</code>函数。</li>
</ol>
</div></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">黑脸花猫.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>