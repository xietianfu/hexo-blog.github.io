<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>《JavaScript高级程序设计》笔记 | 黑脸花猫</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《JavaScript高级程序设计》笔记</h1><a id="logo" href="/.">黑脸花猫</a><p class="description">在这世界上的一切人之中，我最希望予以提升的一个，就是我自己。这话很卑鄙，很自私，也很诚实。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《JavaScript高级程序设计》笔记</h1><div class="post-meta">Aug 1, 2017<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一章-JavaScript简介"><span class="toc-number">1.</span> <span class="toc-text">第一章 JavaScript简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-用处和实现"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 用处和实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二章-在HTML中使用JavaScript"><span class="toc-number">2.</span> <span class="toc-text">第二章 在HTML中使用JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-元素"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三章-基本概念"><span class="toc-number">3.</span> <span class="toc-text">第三章 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-语法"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-变量"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-数据类型"><span class="toc-number">3.3.</span> <span class="toc-text">3.4 数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-语句"><span class="toc-number">3.4.</span> <span class="toc-text">3.5 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-函数"><span class="toc-number">3.5.</span> <span class="toc-text">3.6 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第四章-变量、作用域和内存问题"><span class="toc-number">4.</span> <span class="toc-text">第四章 变量、作用域和内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-基本类型和引用类型的值"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 基本类型和引用类型的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-执行环境及作用域"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 执行环境及作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第五章-引用类型"><span class="toc-number">5.</span> <span class="toc-text">第五章 引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-Array类型"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 Array类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-正则表达式"><span class="toc-number">5.2.</span> <span class="toc-text">5.3 正则表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第六章-面向对象的程序设计"><span class="toc-number">6.</span> <span class="toc-text">第六章 面向对象的程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-创建对象"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-继承"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第七章-函数表达式"><span class="toc-number">7.</span> <span class="toc-text">第七章 函数表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-递归"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-闭包"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第八章-BOM"><span class="toc-number">8.</span> <span class="toc-text">第八章 BOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第九章-客户端检测"><span class="toc-number">9.</span> <span class="toc-text">第九章 客户端检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十章-DOM"><span class="toc-number">10.</span> <span class="toc-text">第十章 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-节点层次"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 节点层次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十一章-DOM扩展"><span class="toc-number">11.</span> <span class="toc-text">第十一章 DOM扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十二章-DOM2与DOM3"><span class="toc-number">12.</span> <span class="toc-text">第十二章 DOM2与DOM3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十三章-事件"><span class="toc-number">13.</span> <span class="toc-text">第十三章 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-事件流"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 事件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-事件处理程序"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 事件处理程序</span></a></li></ol></li></ol></div></div><div class="post-content"><h3 id="第一章-JavaScript简介"><a href="#第一章-JavaScript简介" class="headerlink" title="第一章 JavaScript简介"></a>第一章 JavaScript简介</h3><h4 id="1-1-用处和实现"><a href="#1-1-用处和实现" class="headerlink" title="1.1 用处和实现"></a>1.1 用处和实现</h4><p><strong>用处：</strong>在<code>JavaScript</code>发展早期用来在浏览网页时验证表单，减轻服务器的负担，同时提升使用体验。后来能够实现页面的效果，还可以作为一门后端语言（Node.js）。<br><strong>实现：</strong>由三部分组成：核心（JavaScript）、文档对象模型（DOM）、浏览器对象模型（BOM）。</p>
<ol>
<li>JavaScript：是一门解释型的脚本语言，主要运行在浏览器和Node中。现在生产主要使用的是ES5，马上成为主流的是ES6。</li>
<li>DOM:是针对XML但经过扩展用于HTML的应用编程接口。它把整个页面映射为一个树形多层节点结构。现在的浏览器基本都兼容前三级。<br><strong>主要接口</strong>：（1-4二级，后三级）<ul>
<li>视图（View）：跟踪不同文档视图的接口。</li>
<li>事件（Events）：事件和事件处理的接口。</li>
<li>样式（Style）：基于CSS为元素应用样式的接口。</li>
<li>遍历和范围（Traversal and Range）：遍历和操作文档的接口。</li>
<li>加载和保存（Load and Save）：以同意方式加载和保存文档的方法。</li>
<li>验证（Validation）：验证文档的方法。</li>
</ul>
</li>
<li>BOM:用来处理浏览器的窗口和框架，习惯上吧针对浏览器的JavaScript扩展算作它的一部分。它的标准不是很统一，不同浏览器可能会出现不同的表现，但是现在浏览器的表现差异越来越小。</li>
</ol>
<h3 id="第二章-在HTML中使用JavaScript"><a href="#第二章-在HTML中使用JavaScript" class="headerlink" title="第二章 在HTML中使用JavaScript"></a>第二章 在HTML中使用JavaScript</h3><h4 id="2-1-元素"><a href="#2-1-元素" class="headerlink" title="2.1 元素"></a>2.1 元素</h4><p><strong>标准写法：</strong><code>&lt;script type=&quot;text/javascript&quot; src=&quot;位置&quot;&gt;&lt;/script&gt;</code>或者直接在表记之间写代码。<br><strong>位置：</strong></p>
<ul>
<li><code>&lt;head&gt;</code>中：必须等到文件全部被下载，才呈现页面内容。</li>
<li><code>&lt;body&gt;</code>中：在解析包含的代码之前，页面的内容将完全呈现在浏览器中。通常放在其它的尾部。</li>
</ul>
<h3 id="第三章-基本概念"><a href="#第三章-基本概念" class="headerlink" title="第三章 基本概念"></a>第三章 基本概念</h3><h4 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h4><p>JavaScript的雨大大量借鉴了C及其他类C语法，是一种区分大小写的语法。<br><strong>规范：</strong>格式为驼峰命名规则</p>
<ul>
<li>变量：<em>类型_变量名</em>   <code>s</code>：表示字符串。<code>n</code>：表示数字。<code>b</code>：表示逻辑。<code>a</code>：表示数组。<code>r</code>：表示正则表达式。<code>f</code>：表示函数。<code>o</code>：表示以上未涉及到的其他对象变量在作用域的顶部申明。</li>
<li>常量：全部大写，以下划线分割。</li>
<li>方法（函数）声明：返回统一的类型，首字母小写驼峰式命名并做到见文知意。<code>eg:getUserName()</code>。</li>
<li>类/对象：命名首字母大写，私有方法以<code>_name</code>标注。对象名缩写：text–tex、button–btn、select–sel、option–opt、form–frm、frame–fra、hidden–hdn、对话框对象–dlg、窗口对象–win。</li>
<li>字符串使用单引号。</li>
<li>关键字和函数名后加空格。</li>
<li>使用全等<code>===</code>。</li>
<li>使用浏览器全局变量时加上<code>windows</code>前缀，<code>document</code>和<code>navigator</code>除外。<h4 id="3-2-变量"><a href="#3-2-变量" class="headerlink" title="3.2 变量"></a>3.2 变量</h4>JavaScript的变量时松散类型的，可以用来保存任何类型的数据，变量的作用是保存值的占位符。如果没有使用var定义变量，变量变为全局变量，万不可这么做。<h4 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h4><blockquote>
<p>5种简单的数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>，一种复杂类型<code>Object</code>–由一组无序的名值对组成。</p>
</blockquote>
</li>
</ul>
<p>类型检测：<code>typeof</code>。<br><code>Undefined</code>:主要用来占位和用来比较。<br><code>Null</code>:为认为是一个空的对象引用。<br><code>Boolean</code>：只有两个字面值<code>true</code>和<code>false</code>，开头大写的为标识符。<br><code>Number</code>：八进制以数字0开头，十六进制以0x开头，在进行算数计算时，所有值的最终结果都会被转换为十进制数值。当值的大小超过数字范围后被转换为<code>Infinity</code>,后将无法参与下一次计算。<br>数值转换函数<code>parseInt（）</code>和<code>parseFloat()</code>–只能解析十进制：最好使用第二个参数表明转换后的进制。</p>
<ul>
<li>返回0的有：Boolean值false、null。</li>
<li>返回NaN的有：undefined、第一个字符不是数字或者负号的字符串。</li>
<li>如果是对象，调用对象的<code>valueof()</code>，规则同上。</li>
</ul>
<p><code>String</code>：JavaScript中字符串是不可变的，要改变某个变量中的字符串，首先要销毁原来的字符串，然后再用新值的字符串填充该变量。<br><code>Object</code>:一组无序的名值对组成<br>Object 的每个实例都具有下列属性和方法。</p>
<ul>
<li>constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object()。</li>
<li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如： o.hasOwnProperty(“name”)）。</li>
<li>isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原型）。</li>
<li>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。</li>
<li>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString()：返回对象的字符串表示。</li>
<li>valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值<br>相同。</li>
</ul>
<h4 id="3-5-语句"><a href="#3-5-语句" class="headerlink" title="3.5 语句"></a>3.5 语句</h4><p><strong>switch</strong>:可以使用任何数据类型，无论是字符串，还是对象。每个<code>case</code>的值不一定是常量，可以是变量，表达式。同时在比较值时使用的是全等操作符，不会发生类型转化。</p>
<h4 id="3-6-函数"><a href="#3-6-函数" class="headerlink" title="3.6 函数"></a>3.6 函数</h4><p><strong>理解参数：</strong>函数不介意传递进来多少个参数和参数类型，因为参数在内部使用一个数组来表示的，在函数体内通过<code>arguments</code>对象来访问这个参数数组，从而传递给函数每一个参数。其实<code>arguments</code>只是类似于数组。<br><strong>没有重载：</strong>如果定义了两个同名函数，名字属于后定义的函数。</p>
<h3 id="第四章-变量、作用域和内存问题"><a href="#第四章-变量、作用域和内存问题" class="headerlink" title="第四章 变量、作用域和内存问题"></a>第四章 变量、作用域和内存问题</h3><blockquote>
<p>JavaScript变量松散类型的本质，决定它只是在特定时间用于保存特定的一个名字，变量的值和类型可以在脚本的生命周期内改变。</p>
</blockquote>
<h4 id="4-1-基本类型和引用类型的值"><a href="#4-1-基本类型和引用类型的值" class="headerlink" title="4.1 基本类型和引用类型的值"></a>4.1 基本类型和引用类型的值</h4><blockquote>
<p>基本类型值指的是简单的数据段，引用类型指那些可以由多个值组成的对象。引用类型的值是保存在内存中的<strong>对象</strong>，JavaScript不能直接操作对象的内存空间。在操作对象时，实际上时在操作对象的引用类型而不是实际的对象。</p>
</blockquote>
<p><strong>复制参数：</strong>基本类型复制的是值，引用类型复制的是指针。<br><strong>传递参数：</strong>所有函数的参数都是按值传递的。函数外部的值复制给函数内部的参数，就是从一个变量复制到另一个变量一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    num +=<span class="number">10</span>;</div><div class="line">    <span class="keyword">return</span>  num;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> count =<span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result=addTen(count);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//10</span></div><div class="line"><span class="built_in">console</span>.log(result);  <span class="comment">//20</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    obj.name=<span class="string">"jason"</span>;</div><div class="line"></div><div class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    obj.name=<span class="string">"Ann"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">//"jason"</span></div></pre></td></tr></table></figure></p>
<p>当在函数内部重写obj是，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完成后立即被销毁。<br><strong>检测类型：</strong><code>typeof</code>检测值的类型，<code>instanceof</code>检测引用类型是什么类型的对象。</p>
<h4 id="4-2-执行环境及作用域"><a href="#4-2-执行环境及作用域" class="headerlink" title="4.2 执行环境及作用域"></a>4.2 执行环境及作用域</h4><blockquote>
<p>执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在这个对象中。</p>
<p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 ECMAScript 程序中的执行流正是由这个方便的机制控制着。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。<strong>作用域链</strong>的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）</p>
</blockquote>
<p><strong>没有块级作用域</strong></p>
<h3 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h3><blockquote>
<p>引用类型的值（对象）是<strong>引用类型</strong>的一个实例。在 ECMAScript 中， 引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。引用类型有时候也被称为<strong>对象定义</strong>，因为它们描述的是一类对象所具有的属性和方法。</p>
</blockquote>
<h4 id="5-1-Array类型"><a href="#5-1-Array类型" class="headerlink" title="5.1 Array类型"></a>5.1 Array类型</h4><blockquote>
<p>在同一个数组中，参数可以是不同类型的值。参数还可以是一个新的数组。</p>
</blockquote>
<p><strong>检测数组：</strong><code>Array.isArray()</code>方法，用来确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。<br><strong>转化方法：</strong>对象都具有 <code>toLocaleString()、 toString()和 valueOf()</code>方法。其中，调用数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用 valueOf()返回的还是数组。使用<code>join()</code>可以以不同的分隔符来构建这个字符串。<br><strong>栈方法：</strong>类似压入弹夹的一种数据结构。其拥有的方法<code>push()和pop()</code>。<br><strong>列队方法：</strong>先进先出，拥有方法<code>shift()和push()</code>。<br><strong>重排序方法：</strong><code>sort()</code>方法会调用每个数组项的<code>toString()</code>转化方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，其比较的也是字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">val1,val2</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(val1&lt;val2)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(val1&gt;val2)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> values=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</div><div class="line">values.sort(compare);</div><div class="line"><span class="comment">//values.sort();</span></div><div class="line"><span class="built_in">console</span>.log(values);  <span class="comment">//[0, 1, 5, 10, 15]</span></div></pre></td></tr></table></figure></p>
<p><strong>操作方法：</strong> </p>
<ol>
<li><code>concat()</code>方法可以基于当前数组中的所有项创建一个新数组。</li>
<li><p><code>slice()</code>基于当前数组中的一或多个项创建一个新数组。接受一或两个参数，即要返回项的起始和结束位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</div><div class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">1</span>,<span class="number">4</span>);</div><div class="line">alert(colors3); <span class="comment">//green,blue,yellow</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>splice()</code></p>
<ul>
<li><strong>删除：</strong>可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数.例如， <code>splice(0,2)</code>会删除数组中的前两项。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>插入：</strong>可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，<br><code>splice(2,0,&quot;red&quot;,&quot;green&quot;)</code>会从当前数组的位置 2 开始插入字符串”red”和”green”。</li>
<li><strong>替换：</strong>可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，<code>splice (2,1,&quot;red&quot;,&quot;green&quot;)</code>会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串”red”和”green”。</li>
</ul>
<p><strong>位置方法：</strong><code>indexOf()</code>和 <code>lastIndexOf()</code>。<br><strong>迭代方法：</strong></p>
<ul>
<li><code>every()：</code>对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。</li>
<li><code>filter()：</code>对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>
<li><code>forEach()：</code>对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li><code>map()：</code>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li><code>some()：</code>对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。<br><strong>基本格式：</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> (item &gt; <span class="number">2</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>归并方法：</strong><code>reduce()</code>和 <code>reduceRight()</code>。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中， <code>reduce()</code>方法从数组的第一项开始，逐个遍历到最后。而 <code>reduceRight()</code>则从数组的最后一项开始，向前遍历到第一项。<br>基本格式:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> prev + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum); <span class="comment">//15</span></div></pre></td></tr></table></figure></p>
<h4 id="5-3-正则表达式"><a href="#5-3-正则表达式" class="headerlink" title="5.3 正则表达式"></a>5.3 正则表达式</h4><p><strong>实例方法：</strong></p>
<ul>
<li><p><code>exec（）</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</div><div class="line"><span class="keyword">var</span> matches = pattern.exec(text);</div><div class="line">alert(matches.index); <span class="comment">// 0</span></div><div class="line">alert(matches.input); <span class="comment">// "mom and dad and baby"</span></div><div class="line">alert(matches[<span class="number">0</span>]); <span class="comment">// "mom and dad and baby"</span></div><div class="line">alert(matches[<span class="number">1</span>]); <span class="comment">// " and dad and baby"</span></div><div class="line">alert(matches[<span class="number">2</span>]); <span class="comment">// " and baby"</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>test()</code>:接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回 false。</p>
</li>
</ul>
<p>5.4 Function类型</p>
<blockquote>
<p>函数实际上是对象。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>
</blockquote>
<p><strong>没有重载：</strong>将函数名想象为指针。<br><strong>函数声明与函数表达式：</strong>解析器会率先读取函数声明，并使其在执行任何代码之前可用；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。<br><strong>作为值的函数：</strong>函数名本身就是变量，所有函数可以作为值来使用。不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。<br><strong>函数内部属性：</strong>有两个特殊的对象： <code>arguments 和 this</code>。 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>函数属性和方法–很重要</strong><br>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性了。对于ECMAScript 中的引用类型而言， prototype 是保存它们所有实例方法的真正所在。换句话说，诸如toString()和 valueOf()等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时， prototype 属性的作用是极为重要的（第 6 章将详细介绍）。在 ECMAScript 5 中， prototype 属性是不可枚举的，因此使用 for-in 无法发现。每个函数都包含两个非继承而来的方法： apply()和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。首先， apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是arguments 对象。<br><strong>方法：</strong>call()方法与 apply()方法的作用相同，能够传递参数。最重要的是能够扩充函数赖以运行的作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</div><div class="line">&#125;</div><div class="line">alert(callSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div><div class="line"></div><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor(); <span class="comment">//red</span></div><div class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">//red</span></div><div class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">//red</span></div><div class="line">sayColor.call(o); <span class="comment">//blue</span></div></pre></td></tr></table></figure></p>
<h3 id="第六章-面向对象的程序设计"><a href="#第六章-面向对象的程序设计" class="headerlink" title="第六章 面向对象的程序设计"></a>第六章 面向对象的程序设计</h3><blockquote>
<p>JavaScript没有类的概念，但可以把它的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。每个对象都是基于一个引用类型创建的，这个引用类型可以是第5章讨论的原生类型，也可以是开发人员定义的类型。</p>
</blockquote>
<h4 id="6-1-创建对象"><a href="#6-1-创建对象" class="headerlink" title="6.1 创建对象"></a>6.1 创建对象</h4><p><strong>工厂模式：</strong>是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。但是JavaScript无法创建类，就使用一种函数来封装以特定接口创建对象的细节。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.name = name;</div><div class="line">o.age = age;</div><div class="line">o.job = job;</div><div class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure></p>
<p><strong>构造函数模式：</strong>创建自定义的构造函数，从而定义自定义对象类型的属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.job = job;</div><div class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure></p>
<p>注意：构造函数第一个字母为大写，用于区别其它的函数。<br>构造函数可以作为普通函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当作构造函数使用</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">person.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line"><span class="comment">// 作为普通函数调用</span></div><div class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>); <span class="comment">// 添加到 window</span></div><div class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//"Greg"</span></div></pre></td></tr></table></figure></p>
<p>构造函数的问题:每个方法都要在每个实例上重新创建一遍。ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建 Function 新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(person1.sayName == person2.sayName); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p><strong>原型模式：（很重要）</strong>每个函数都有一个 <code>prototype</code>（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 <code>prototype</code> 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    name: <span class="string">"jason"</span>,</div><div class="line">    age: <span class="number">20</span>,</div><div class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p><strong>理解原型对象：</strong>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 <code>prototype</code>属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 <code>constructor</code>（构造函数）属性，这个属性包含一个指向 <code>prototype</code> 属性所在函数的指针。就拿前面的例子来说，<code>Person.prototype. constructor</code> 指向 <code>Person</code>。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。创建了自定义的构造函数之后，其原型对象默认只会取得 <code>constructor</code> 属性；至于其他方法，则都是从 <code>Object</code> 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。 ECMA-262 第 5 版中管这个指针叫<code>[[Prototype]]</code>。虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、 Safari 和 Chrome 在每个对象上都支持一个属性<code>__proto__</code>；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。以前面使用 Person 构造函数和 <code>Person.prototype</code> 创建实例的代码。<br><img src="《JavaScript高级程序设计》笔记/1500542506840.png" alt="Alt text"></p>
<p>当对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，但是不会修改这个属性。<br><strong>in操作符：</strong>通过对象能够访问到属性就返回<code>true</code>，<code>hasOwnProperty()</code>只在属性存在于实例中才返回<code>true</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">//来自原型</span></div><div class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1);  <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p><strong>组合使用构造函数模式和原型模式：</strong>构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。好处是节省内存的同时支持构造函数传递参数。</p>
<h4 id="6-2-继承"><a href="#6-2-继承" class="headerlink" title="6.2 继承"></a>6.2 继承</h4><blockquote>
<p>由于函数没有签名，JavaScript无法实现接口继承，只支持实现继承，其依靠原型链来实现。</p>
</blockquote>
<p><strong>原型链：</strong>基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br><strong>构造函数、原型和实例的关系：</strong>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承了 SuperType</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue()); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p><img src="《JavaScript高级程序设计》笔记/1500715625112.png" alt="Alt text"><br>在通过原型链实现继承是，不能使用对象字面量创建原型方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承了 SuperType</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"><span class="comment">//使用字面量添加新方法，会导致上一行代码无效</span></div><div class="line">SubType.prototype = &#123;</div><div class="line">getSubValue : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;,</div><div class="line">someOtherMethod : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue()); <span class="comment">//error!</span></div></pre></td></tr></table></figure></p>
<p><strong>原型链的问题：</strong>包含引用类型值的原型。包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承了 SuperType</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors); <span class="comment">//"red,blue,green,black"</span></div></pre></td></tr></table></figure></p>
<p><strong>借用构造函数：</strong>在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过使用<code>apply（）</code>和<code>call（）</code>方法也可以在新创建的对象上执行构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//继承了 SuperType</span></div><div class="line">SuperType.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></div></pre></td></tr></table></figure></p>
<p><strong>传递参数：</strong>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中想超类型构造函数传递参数。<br><strong>组合继承：</strong>将原型链和借用构造函数的技术节后到一块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line"><span class="comment">//继承属性</span></div><div class="line">SuperType.call(<span class="keyword">this</span>, name);</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承方法</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></div><div class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></div><div class="line">instance1.sayAge(); <span class="comment">//29</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</div><div class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></div><div class="line">instance2.sayName(); <span class="comment">//"Greg";</span></div><div class="line">instance2.sayAge(); <span class="comment">//27</span></div></pre></td></tr></table></figure></p>
<h3 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="headerlink" title="第七章 函数表达式"></a>第七章 函数表达式</h3><blockquote>
<p><strong>函数声明提升：</strong>在执行代码之前会先读取函数声明。这意味着可以把函数声明放在调用它的语句后面。<br>创建一个函数并将它赋值给变量，这种情况下创建的函数叫做<strong>匿名函数</strong>。其<code>name</code>属性时空字符串。</p>
</blockquote>
<h4 id="7-1-递归"><a href="#7-1-递归" class="headerlink" title="7.1 递归"></a>7.1 递归</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> num * f(num<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line">&#125;);<span class="comment">//严格模式下也可以使用</span></div></pre></td></tr></table></figure>
<h4 id="7-2-闭包"><a href="#7-2-闭包" class="headerlink" title="7.2 闭包"></a>7.2 闭包</h4><blockquote>
<p>闭包是指有权访问另一个函数作用域中变量的函数。创建闭包的常用方式，就是在一个函数内部创建另一个函数。</p>
</blockquote>
<p>一、变量的作用域<br>要理解闭包，首先必须理解Javascript特殊的变量作用域。<br>变量的作用域无非就是两种：全局变量和局部变量。<br>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　alert(n);</div><div class="line">　　&#125;</div><div class="line">　　f1(); <span class="comment">// 999</span></div><div class="line">另一方面，在函数外部自然无法读取函数内的局部变量。</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　&#125;</div><div class="line">　　alert(n); <span class="comment">// error</span></div><div class="line">这里有一个地方需要注意，函数内部声明变量的时候，一定要使用<span class="keyword">var</span>命令。如果不用的话，你实际上声明了一个全局变量！</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　n=<span class="number">999</span>;</div><div class="line">　　&#125;</div><div class="line">　　f1();</div><div class="line">　　alert(n); <span class="comment">// 999</span></div></pre></td></tr></table></figure></p>
<p>二、如何从外部读取局部变量？<br>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。<br>那就是在函数的内部，再定义一个函数。
　　</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　alert(n); <span class="comment">// 999</span></div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。<br>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　alert(n);</div><div class="line">　　　　&#125;</div><div class="line">　　　　<span class="keyword">return</span> f2;</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">var</span> result=f1();</div><div class="line">　　result(); <span class="comment">// 999</span></div></pre></td></tr></table></figure></p>
<p>三、闭包的概念<br>上一节代码中的f2函数，就是闭包。<br>各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。<br>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。<br>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。<br>四、闭包的用途<br>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br>怎么来理解这句话呢？请看下面的代码。
　　</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　　　nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</div><div class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　alert(n);</div><div class="line">　　　　&#125;</div><div class="line">　　　　<span class="keyword">return</span> f2;</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">var</span> result=f1();</div><div class="line">　　result(); <span class="comment">// 999</span></div><div class="line">　　nAdd();</div><div class="line">　　result(); <span class="comment">// 1000</span></div></pre></td></tr></table></figure>
<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。<br>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。<br>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。<br>五、使用闭包的注意点<br>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。<br>六、思考题<br>如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。<br>代码片段一。
　　</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line">　　<span class="keyword">var</span> object = &#123;</div><div class="line">　　　　name : <span class="string">"My Object"</span>,</div><div class="line">　　　　getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">　　　　　　&#125;;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;;</div><div class="line">　　alert(object.getNameFunc()());</div></pre></td></tr></table></figure>
<p>代码片段二。
　　</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line">　　<span class="keyword">var</span> object = &#123;</div><div class="line">　　　　name : <span class="string">"My Object"</span>,</div><div class="line">　　　　getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">　　　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">return</span> that.name;</div><div class="line">　　　　　　&#125;;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;;</div><div class="line">　　alert(object.getNameFunc()());</div></pre></td></tr></table></figure>
<h3 id="第八章-BOM"><a href="#第八章-BOM" class="headerlink" title="第八章 BOM"></a>第八章 BOM</h3><p><strong>间歇调用和超时调用：</strong>JavaScript是单线程语言，但他允许通过设置超时值和间歇值来调度代码在特定的时刻执行，前者是在指定的时间过后执行代码，而后者这是在每隔指定的时间后执行一次代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">alert(<span class="string">"Hello world!"</span>);</div><div class="line">&#125;, <span class="number">1000</span>);<span class="comment">//超时调用</span></div><div class="line"></div><div class="line">setInterval (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">alert(<span class="string">"Hello world!"</span>);</div><div class="line">&#125;, <span class="number">10000</span>);<span class="comment">//间隔调用</span></div></pre></td></tr></table></figure></p>
<p><strong>系统对话框：</strong><code>alert() confirm()--确认、批准 prompt()</code><br><strong>location对象：</strong>提供当前窗口中加载的文档有关的信息，还提供一些导航功能。<br><img src="《JavaScript高级程序设计》笔记/1501143986241.png" alt="Alt text"></p>
<h3 id="第九章-客户端检测"><a href="#第九章-客户端检测" class="headerlink" title="第九章 客户端检测"></a>第九章 客户端检测</h3><p>略</p>
<h3 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h3><h4 id="10-1-节点层次"><a href="#10-1-节点层次" class="headerlink" title="10.1 节点层次"></a>10.1 节点层次</h4><p><img src="《JavaScript高级程序设计》笔记/1501144258255.png" alt="Alt text"></p>
<p>JavaScript中的所有节点类型都继承自<code>Node</code>类型，因此所有节点类型都共享者相同的基本属性和方法。</p>
<ul>
<li>Node.ELEMENT_NODE(1)；</li>
<li>Node.ATTRIBUTE_NODE(2)；</li>
<li>Node.TEXT_NODE(3)；</li>
<li>Node.CDATA_SECTION_NODE(4)；</li>
<li>Node.ENTITY_REFERENCE_NODE(5)；</li>
<li>Node.ENTITY_NODE(6)；</li>
<li>Node.PROCESSING_INSTRUCTION_NODE(7)；</li>
<li>Node.COMMENT_NODE(8)；</li>
<li>Node.DOCUMENT_NODE(9)；</li>
<li>Node.DOCUMENT_TYPE_NODE(10)；</li>
<li>Node.DOCUMENT_FRAGMENT_NODE(11)；</li>
<li>Node.NOTATION_NODE(12)。</li>
</ul>
<p>对节点进行比较时，为保证兼容性，最好将<code>nodeType</code>属性与数字进行比较。</p>
<p><strong>文档节点间的关系图：</strong><br><img src="《JavaScript高级程序设计》笔记/1501144625077.png" alt="Alt text"></p>
<p><strong>操作节点：</strong>四个方法都是某个节点的子节点，所以应该先取得其父节点。<br>![Alt text]《JavaScript高级程序设计》笔记/1501145028489.png)</p>
<h3 id="第十一章-DOM扩展"><a href="#第十一章-DOM扩展" class="headerlink" title="第十一章 DOM扩展"></a>第十一章 DOM扩展</h3><h3 id="第十二章-DOM2与DOM3"><a href="#第十二章-DOM2与DOM3" class="headerlink" title="第十二章 DOM2与DOM3"></a>第十二章 DOM2与DOM3</h3><h3 id="第十三章-事件"><a href="#第十三章-事件" class="headerlink" title="第十三章 事件"></a>第十三章 事件</h3><h4 id="13-1-事件流"><a href="#13-1-事件流" class="headerlink" title="13.1 事件流"></a>13.1 事件流</h4><p>IE 的事件流是事件冒泡流，而 Netscape Communicator 的事件流是事件捕获流。两种流是相反的。<br>![Alt text|center]《JavaScript高级程序设计》笔记/1501145480005.png)<br>DOM事件流：<br>![Alt text|center]《JavaScript高级程序设计》笔记/1501145542942.png)</p>
<h4 id="13-2-事件处理程序"><a href="#13-2-事件处理程序" class="headerlink" title="13.2 事件处理程序"></a>13.2 事件处理程序</h4><p>“DOM2 级事件” 定义了两个方法，用于处理指定和删除事件处理程序的操作： addEventListener()和 removeEventListener()。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;;</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</div><div class="line"><span class="comment">//这里省略了其他代码</span></div><div class="line">btn.removeEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</div></pre></td></tr></table></figure></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="blog.xxtian.me/2017/08/01/《JavaScript高级程序设计》笔记/" data-id="cj6uj2x2y0002pku5uoldyvmv" class="article-share-link">分享</a><div class="tags"><a href="/tags/笔记/">笔记</a><a href="/tags/书籍/">书籍</a></div><div class="post-nav"><a href="/2017/07/27/《响应式web设计》-笔记/" class="next">《响应式web设计》--笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="blog.xxtian.me"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Diary/">Diary</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/PS3/" style="font-size: 15px;">PS3</a> <a href="/tags/Games/" style="font-size: 15px;">Games</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/书籍/" style="font-size: 15px;">书籍</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/《JavaScript高级程序设计》笔记/">《JavaScript高级程序设计》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/《响应式web设计》-笔记/">《响应式web设计》--笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/01/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">黑脸花猫.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>